ApplyPriceErrorThresholds: THEORY
BEGIN
  IMPORTING CheckPriceErrorBound_Lemmas

  %-----------------------------
  % Result type
  %-----------------------------
  ExchangeResultV10: TYPE = [#
    numWheatReceived: int64,
    numSheepSend:     int64,
    wheatStays:       bool
  #]

  %-----------------------------
  % Rounding types + state
  %-----------------------------
  RoundingType: TYPE = { NORMAL, PATH_PAYMENT_STRICT_RECEIVE, PATH_PAYMENT_STRICT_SEND }

  State: TYPE = [#
    price:  Price,
    wheatStays: bool,
    sS: nnint64,
    wR: nnint64,
    round:  RoundingType
  #]

  wf_state?(s: State) : bool =
    (PATH_PAYMENT_STRICT_SEND?(s`round) IMPLIES NOT (s`sS = 0)) AND
    ((s`wR > 0 AND s`sS > 0 AND s`wheatStays) IMPLIES s`price`d * s`sS >= s`price`n * s`wR) AND
    ((s`wR > 0 AND s`sS > 0 AND NOT s`wheatStays) IMPLIES s`price`n * s`wR >= s`price`d * s`sS)

  
  wf_state : TYPE = (wf_state?)

  %-----------------------------
  % Integer price-comparison predicates
  %-----------------------------
  % favors_wheat?: S/W >= n/d  <=>  S*d >= W*n
  favors_wheat?(res: ExchangeResultV10, p: Price): bool =
    res`numSheepSend * p`d >= res`numWheatReceived * p`n

  % favors_sheep?: S/W <= n/d  <=>  S*d <= W*n
  favors_sheep?(res: ExchangeResultV10, p: Price): bool =
    res`numSheepSend * p`d <= res`numWheatReceived * p`n

  % 1% favor bounds in integers:
  % If wheat favored: S/W <= (101/100)*(n/d)  <=>  S*d*100 <= W*n*101
  within_one_percent_when_wheat_favored?(res: ExchangeResultV10, p: Price): bool =
    (res`numSheepSend * p`d * 100) <= (res`numWheatReceived * p`n * 101)

  % If sheep favored: S/W >= (100/101)*(n/d)  <=>  S*d*101 >= W*n*100
  within_one_percent_when_sheep_favored?(res: ExchangeResultV10, p: Price): bool =
    (res`numSheepSend * p`d * 101) >= (res`numWheatReceived * p`n * 100)

  %exchangeSS: TYPE = {i: nnint64 | IF round i >= 0 }
  %exchangeV10(Price price, int64_t maxWheatSend, int64_t maxWheatReceive, int64_t maxSheepSend, int64_t maxSheepReceive, RoundingType round) : ExchangeResultV10 = 
  %exchangeV10(s: wf_state) : ExchangeResultV10 = 

  %-----------------------------
  % Threshold adjustment
  %-----------------------------
  applyPriceErrorThresholds(s: wf_state): ExchangeResultV10 =
  %applyPriceErrorThresholds(p: Price, wheatReceive: nnint64, sheepSend: nnint64, wheatStays: bool, round: RoundingType): ExchangeResultV10 =
    LET wR = s`wR, sS = s`sS, round = s`round, wheatStays = s`wheatStays,
      adj_pair: [# wr: int64, ss: int64 #] =
        IF (wR > 0 AND sS > 0) THEN
          IF round = NORMAL THEN
            IF checkPriceErrorBound(s`price, wR, sS, False)
              THEN (# wr := wR, ss := sS #)
              ELSE (# wr := 0, ss := 0 #) ENDIF
          ELSE
            IF checkPriceErrorBound(s`price, wR, sS, True)
            THEN (# wr := wR, ss := sS #)
            ELSE (# wr := wR, ss := sS #) ENDIF
          ENDIF
        ELSE
          CASES round OF
            PATH_PAYMENT_STRICT_SEND: (# wr := 0, ss := sS #),
            NORMAL: (# wr := 0, ss := 0 #),
            PATH_PAYMENT_STRICT_RECEIVE: (# wr := 0, ss := 0 #)
          ENDCASES
        ENDIF
    IN (# numWheatReceived := adj_pair`wr,
        numSheepSend     := adj_pair`ss,
        wheatStays       := wheatStays #)
END ApplyPriceErrorThresholds



ApplyPriceErrorThresholds_Lemmas: THEORY
BEGIN

  IMPORTING ApplyPriceErrorThresholds

  %---------------------------------------------------------------------------
  % â‰¤1% bound when in NORMAL mode
  %---------------------------------------------------------------------------
  thresholds_normal_bounded_error_no_trade: LEMMA
    FORALL (s: wf_state):
      LET r = applyPriceErrorThresholds(s),
        price = (s`price`n/s`price`d), effP = (s`sS/s`wR)
      IN (s`round = NORMAL) AND (s`wR > 0 AND s`sS > 0) AND
        NOT (abs(price - effP)/(price) <= 1/100) IMPLIES
        (r`numWheatReceived = 0 AND r`numSheepSend = 0)
  
  thresholds_normal_bounded_error_successful: LEMMA
    FORALL (s: wf_state):
      LET r = applyPriceErrorThresholds(s),
        price = (s`price`n/s`price`d), effP = (s`sS/s`wR)
      IN (s`round = NORMAL) AND (s`wR > 0 AND s`sS > 0) AND
        (abs(price - effP)/(price) <= 1/100) IMPLIES
        (r`numWheatReceived = s`wR AND r`numSheepSend = s`sS)

  %---------------------------------------------------------------------------
  % Unbounded rounding error when not in NORMAL mode
  %---------------------------------------------------------------------------
  %thresholds_path_error_unbounded_favor_sheep: LEMMA
  %  FORALL (s: wf_state):
  %    LET r = applyPriceErrorThresholds(s),
  %      price = (s`price`n/s`price`d), effP = (s`sS/s`wR)
  %    IN (s`round = NORMAL) AND (s`wR > 0 AND s`sS > 0) AND
  %      (abs(price - effP)/(price) >= 0) IMPLIES
  %      (r`numWheatReceived = s`wR AND r`numSheepSend = s`sS)

  %---------------------------------------------------------------------------
  % No trade happens when effectivePrice = 0 (NORMAL)
  %---------------------------------------------------------------------------
  thresholds_normal_no_trade_if_wR_or_sS_equal_zero: LEMMA
    FORALL (s: wf_state):
      LET r = applyPriceErrorThresholds(s)
      IN (s`round = NORMAL) AND (s`wR = 0 OR s`sS = 0) IMPLIES
        (r`numWheatReceived = 0 AND r`numSheepSend = 0)

  %---------------------------------------------------------------------------
  % No trade happens when effectivePrice = 0 (PATH_PAYMENT_STRICT_RECEIVE)
  %---------------------------------------------------------------------------
  thresholds_path_receive_no_trade_if_wR_or_sS_equal_zero: LEMMA
    FORALL (s: wf_state):
      LET r = applyPriceErrorThresholds(s)
      IN (s`round = PATH_PAYMENT_STRICT_RECEIVE) AND (s`wR = 0 OR s`sS = 0)
        IMPLIES (r`numWheatReceived = 0 AND r`numSheepSend = 0)
  
  %---------------------------------------------------------------------------
  % Sell sheep for no wheat allowed (PATH_PAYMENT_STRICT_SEND mode)
  %---------------------------------------------------------------------------
  thresholds_path_send_sS_not_zero_if_wR_or_sS_equal_zero: LEMMA
    FORALL (s: wf_state):
      LET r = applyPriceErrorThresholds(s)
      IN (s`round = PATH_PAYMENT_STRICT_SEND) AND (s`wR = 0 OR s`sS = 0)
        IMPLIES NOT (s`sS = 0)
 
  %---------------------------------------------------------------------------
  % Sell sheep for no wheat recorded (PATH_PAYMENT_STRICT_SEND mode)
  %---------------------------------------------------------------------------
  record_path_send_sS_not_zero_if_wR_or_sS_equal_zero: LEMMA
    FORALL (s: wf_state):
      LET r = applyPriceErrorThresholds(s)
      IN (s`round = PATH_PAYMENT_STRICT_SEND) AND (s`wR = 0)
        IMPLIES (r`numWheatReceived = 0 AND r`numSheepSend = s`sS)

END ApplyPriceErrorThresholds_Lemmas

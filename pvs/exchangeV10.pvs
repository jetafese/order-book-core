ExchangeV10: THEORY
BEGIN
  IMPORTING ApplyPriceErrorThresholds_Lemmas
  IMPORTING interval_arith@top

  %-----------------------------
  % Integer domains
  %-----------------------------
  max128: uint128 = exp2(128)-1

  %-----------------------------
  % Rounding modes and helpers
  %-----------------------------
  RoundMode: TYPE = { ROUND_DOWN, ROUND_UP }
  
  big_div(x: uint128, y: posint64, r: RoundMode): nnint64 =
    CASES r OF
      ROUND_DOWN: IF x/y <= max64 THEN ndiv(x,y) ELSE 0 ENDIF,
      ROUND_UP:   IF (x + y - 1) <= max128 AND (x + y - 1) > 0 AND (x + y - 1)/y <= max64
                  THEN ndiv(x + y - 1, y)
                  ELSE 0
                  ENDIF
    ENDCASES

  big_div_numden(x: nnint64, n: posint64, d: posint64, r: RoundMode): nnint64 =
    % Computes round( x * n / d ) using integer rounding
    CASES r OF
      ROUND_DOWN: IF (x*n/d) <= max64 THEN  ndiv((x * n), d) ELSE 0 ENDIF,
      ROUND_UP:   IF ((x*n+(d-1))/d) <= max64 THEN ndiv((x * n + (d - 1)), d) ELSE 0 ENDIF
    ENDCASES
  
  %-----------------------------
  % exchange invariants
  %-----------------------------
  Inv: TYPE = [#
    price: Price,
    maxWheatSend: nnint64,
    maxWheatReceive: posint64,
    maxSheepSend: posint64,
    maxSheepReceive: nnint64,
    round: RoundingType
  #]

  inv_state?(i: Inv) : bool =
    (i`round = PATH_PAYMENT_STRICT_SEND IMPLIES (i`maxSheepSend > 0 AND i`maxSheepReceive > 0))

  inv_state : TYPE = (inv_state?)

  %-----------------------------
  % Offer value calculation
  %-----------------------------
  % calculateOfferValue(n, d, maxSend, maxReceive) =
  %   min(maxSend * n, maxReceive * d)
  calculateOfferValue(n: nnint32, d: nnint32,
    maxSend: nnint64, maxReceive: nnint64): uint128 =
    min(big_mul(maxSend, n), big_mul(maxReceive, d))

  %-----------------------------
  % Core function (no thresholds)
  %-----------------------------
  exchangeV10WithoutPriceErrorThresholds(i: inv_state): wf_state =
    LET
      price = i`price,
      maxWheatSend = i`maxWheatSend,
      maxWheatReceive = i`maxWheatReceive,
      maxSheepSend = i`maxSheepSend,
      maxSheepReceive = i`maxSheepReceive,
      round = i`round,
      wheatValue: uint128 = calculateOfferValue(price`n, price`d,
                                             maxWheatSend, maxSheepReceive),
      sheepValue: uint128 = calculateOfferValue(price`d, price`n,
                                             maxSheepSend, maxWheatReceive),
      wheatStays: bool = (wheatValue > sheepValue),

      wheatReceive: nnint64 =
        IF wheatStays THEN
          IF round = PATH_PAYMENT_STRICT_SEND THEN
            big_div(sheepValue, price`n, ROUND_DOWN)
          ELSIF (price`n > price`d OR round = PATH_PAYMENT_STRICT_RECEIVE) THEN
            % wheat is more valuable
            big_div(sheepValue, price`n, ROUND_DOWN)
          ELSE
            % sheep is more valuable, wheatStays: compute sheepSend first
            LET sheepSend_tmp = big_div(sheepValue, price`d, ROUND_DOWN) IN
              big_div_numden(sheepSend_tmp, price`d, price`n, ROUND_DOWN)
          ENDIF
        ELSE
          IF price`n > price`d THEN
	    % KN: wheat is more valuable
            big_div(wheatValue, price`n, ROUND_DOWN)
          ELSE
            % sheep is more valuable, !wheatStays: compute sheepSend first
            LET sheepSend_tmp = big_div(wheatValue, price`d, ROUND_DOWN) IN
              big_div_numden(sheepSend_tmp, price`d, price`n, ROUND_UP)
          ENDIF
        ENDIF,

      sheepSend: nnint64 =
        IF wheatStays THEN
          IF round = PATH_PAYMENT_STRICT_SEND THEN
            IF maxSheepSend <= maxSheepReceive
            THEN maxSheepSend
            ELSE maxSheepReceive ENDIF
          ELSIF price`n > price`d OR round = PATH_PAYMENT_STRICT_RECEIVE THEN
            big_div_numden(wheatReceive, price`n, price`d, ROUND_UP)
          ELSE
            big_div(sheepValue, price`d, ROUND_DOWN)
          ENDIF
        ELSE
          IF price`n > price`d THEN
            big_div_numden(wheatReceive, price`n, price`d, ROUND_DOWN)
          ELSE
            big_div(wheatValue, price`d, ROUND_DOWN)
          ENDIF
        ENDIF
    IN
      (# price:= price, wheatStays := wheatStays, sS := sheepSend, wR := wheatReceive, round := round #)

  %-----------------------------
  % Public wrapper exchangeV10
  %-----------------------------
  % types justified by crossOfferV10
  exchangeV10(i: inv_state): ExchangeResultV10 =
    LET before = exchangeV10WithoutPriceErrorThresholds(i)
    IN applyPriceErrorThresholds(before)

END ExchangeV10

ExchangeV10_Lemmas: THEORY
BEGIN

  IMPORTING ExchangeV10

  %---------------------------------------------------------------------------
  % wheatStays determined correctly
  %---------------------------------------------------------------------------
  wheatStays_exchangeV10WithoutPriceErrorThresholds: LEMMA
    FORALL (i: inv_state):
      LET state = exchangeV10WithoutPriceErrorThresholds(i),
          wheatOfferInTermsOfSheep = min(i`maxWheatSend * i`price`n, i`maxSheepReceive * i`price`d),
          sheepOfferInTermsOfSheep = min(i`maxWheatReceive * i`price`n, i`maxSheepSend * i`price`d)
      IN state`wheatStays IFF wheatOfferInTermsOfSheep > sheepOfferInTermsOfSheep

  %---------------------------------------------------------------------------
  % when wheatStays and round=SEND, wf_state (1) holds
  %---------------------------------------------------------------------------
  wheatStays_pathSend_nn: LEMMA
    FORALL (i: inv_state):
      LET s = exchangeV10WithoutPriceErrorThresholds(i)
      IN ((s`wheatStays AND s`round = PATH_PAYMENT_STRICT_SEND) IMPLIES s`sS > 0 AND s`wR >= 0)

  %---------------------------------------------------------------------------
  % when wheatStays and nonzero trade, wf_state (2) holds for any rounding
  %---------------------------------------------------------------------------
  wheatStays_nztrade_moreSheep_than_wheat: LEMMA
    FORALL (i: inv_state):
      LET s = exchangeV10WithoutPriceErrorThresholds(i)
      IN ((s`wR > 0 AND s`sS > 0 AND s`wheatStays) IMPLIES s`price`d * s`sS >= s`price`n * s`wR)

  %---------------------------------------------------------------------------
  % when not wheatStays and nonzero trade, wf_state (3) holds for any rounding
  %---------------------------------------------------------------------------
  not_wheatStays_nztrade_lessSheep_than_wheat: LEMMA
    FORALL (i: inv_state):
      LET s = exchangeV10WithoutPriceErrorThresholds(i)
      IN ((s`wR > 0 AND s`sS > 0 AND NOT s`wheatStays) IMPLIES s`price`n * s`wR >= s`price`d * s`sS)

END ExchangeV10_Lemmas

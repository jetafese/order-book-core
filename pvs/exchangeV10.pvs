ExchangeV10: THEORY
BEGIN
  IMPORTING ApplyPriceErrorThresholds_Lemmas
  IMPORTING interval_arith@top

  %-----------------------------
  % Integer domains
  %-----------------------------
  max128: uint128 = exp2(128)-1

  %-----------------------------
  % Rounding modes and helpers
  %-----------------------------
  RoundMode: TYPE = { ROUND_DOWN, ROUND_UP }
  

  big_div(x: uint128, y: posint64, r: RoundMode): nnint64 =
    CASES r OF
      ROUND_DOWN: IF x/y <= max64 THEN ndiv(x,y) ELSE 0 ENDIF,
      ROUND_UP:   IF (x + y - 1) <= max128 AND (x + y - 1) > 0 AND (x + y - 1)/y <= max64
                  THEN ndiv(x + y - 1, y)
                  ELSE 0
                  ENDIF
    ENDCASES

  big_div_numden(x: nnint64, n: posint64, d: posint64, r: RoundMode): nnint64 =
    % Computes round( x * n / d ) using integer rounding
    CASES r OF
      ROUND_DOWN: IF (x*n/d) <= max64 THEN  ndiv((x * n), d) ELSE 0 ENDIF,
      ROUND_UP:   IF ((x*n+(d-1))/d) <= max64 THEN ndiv((x * n + (d - 1)), d) ELSE 0 ENDIF
    ENDCASES
  
  %-----------------------------
  % Offer value calculation
  %-----------------------------
  % calculateOfferValue(n, d, maxSend, maxReceive) =
  %   min(maxSend * n, maxReceive * d)
  calculateOfferValue(n: nnint32, d: nnint32,
    maxSend: nnint64, maxReceive: nnint64): uint128 =
    min(big_mul(maxSend, n), big_mul(maxReceive, d))

  %-----------------------------
  % Core function (no thresholds)
  %-----------------------------
  exchangeV10WithoutPriceErrorThresholds(price: Price, maxWheatSend: nnint64,
        maxWheatReceive: posint64, maxSheepSend: posint64,
        maxSheepReceive: nnint64, round: RoundingType): wf_state =
    LET
      wheatValue: uint128 = calculateOfferValue(price`n, price`d,
                                             maxWheatSend, maxSheepReceive),
      sheepValue: uint128 = calculateOfferValue(price`d, price`n,
                                             maxSheepSend, maxWheatReceive),
      wheatStays: bool = (wheatValue > sheepValue),

      wheatReceive: nnint64 =
        IF wheatStays THEN
          IF round = PATH_PAYMENT_STRICT_SEND THEN
            big_div(sheepValue, price`n, ROUND_DOWN)
          ELSIF (price`n > price`d OR round = PATH_PAYMENT_STRICT_RECEIVE) THEN
            % wheat is more valuable
            big_div(sheepValue, price`n, ROUND_DOWN)
          ELSE
            % sheep is more valuable, wheatStays: compute sheepSend first
            LET sheepSend_tmp = big_div(sheepValue, price`d, ROUND_DOWN) IN
              big_div_numden(sheepSend_tmp, price`d, price`n, ROUND_DOWN)
          ENDIF
        ELSE
          IF price`n > price`d THEN
	    % KN: wheat is more valuable
            big_div(wheatValue, price`n, ROUND_DOWN)
          ELSE
            % sheep is more valuable, !wheatStays: compute sheepSend first
            LET sheepSend_tmp = big_div(wheatValue, price`d, ROUND_DOWN) IN
              big_div_numden(sheepSend_tmp, price`d, price`n, ROUND_UP)
          ENDIF
        ENDIF,

      sheepSend: nnint64 =
        IF wheatStays THEN
          IF round = PATH_PAYMENT_STRICT_SEND THEN
            IF maxSheepSend <= maxSheepReceive
            THEN maxSheepSend
            ELSE maxSheepReceive ENDIF
          ELSIF price`n > price`d OR round = PATH_PAYMENT_STRICT_RECEIVE THEN
            big_div_numden(wheatReceive, price`n, price`d, ROUND_UP)
          ELSE
            big_div(sheepValue, price`d, ROUND_DOWN)
          ENDIF
        ELSE
          IF price`n > price`d THEN
            big_div_numden(wheatReceive, price`n, price`d, ROUND_DOWN)
          ELSE
            big_div(wheatValue, price`d, ROUND_DOWN)
          ENDIF
        ENDIF,

      % Spec-side bounds checks mirroring the code's throws
      minWheatCap: nnint64 = IF maxWheatReceive <= maxWheatSend 
                          THEN maxWheatReceive ELSE maxWheatSend ENDIF,
      minSheepCap: nnint64 = IF maxSheepReceive <= maxSheepSend
                          THEN maxSheepReceive ELSE maxSheepSend ENDIF,
      chk1: bool = wheatReceive <= minWheatCap,
      chk2: bool = sheepSend     <= minSheepCap
    IN
      IF NOT chk1 OR NOT chk2 THEN
        % In C++ this would throw. Here we return a neutralized result.
        (# price:= price, wheatStays := wheatStays,
          sS := 0, wR := 0, round := round #)
      ELSE
        (# price:= price, wheatStays := wheatStays,
          sS := sheepSend, wR := wheatReceive, round := round #)
      ENDIF

  %-----------------------------
  % Public wrapper exchangeV10
  %-----------------------------
  % types justified by crossOfferV10
  exchangeV10(price: Price, maxWheatSend: nnint64, maxWheatReceive: posint64,
        maxSheepSend: posint64, maxSheepReceive: nnint64,
        round: RoundingType): ExchangeResultV10 =
    LET before = exchangeV10WithoutPriceErrorThresholds(price, maxWheatSend,
                   maxWheatReceive, maxSheepSend, maxSheepReceive, round)
    IN applyPriceErrorThresholds(before)

END ExchangeV10

ExchangeV10_Lemmas: THEORY
BEGIN

  IMPORTING ExchangeV10

  %---------------------------------------------------------------------------
  % exchangeV10WithoutPriceErrorThresholds is wellformed
  %---------------------------------------------------------------------------
  well_formed_exchangeV10WithoutPriceErrorThresholds: LEMMA
    FORALL (price: Price, maxWheatSend: nnint64, maxWheatReceive: posint64,
        maxSheepSend: posint64, maxSheepReceive: nnint64,round: RoundingType):
      LET state = exchangeV10WithoutPriceErrorThresholds(price, maxWheatSend,
                   maxWheatReceive, maxSheepSend, maxSheepReceive, round)
      IN wf_state?(state)

END ExchangeV10_Lemmas
